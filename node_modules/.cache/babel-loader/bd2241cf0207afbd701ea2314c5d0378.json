{"ast":null,"code":"import { SIZE } from '../constants';\nimport { correctUnitsShift, getUnitX, nodeCount, sameAs } from '../utils/units';\nimport { rightOf, unitNodesCount, widthOf } from '../utils/family';\nimport { nextIndex } from '../utils';\n\nvar arrangeNextFamily = function arrangeNextFamily(family, nextFamily) {\n  var unit = family.children[0];\n  var index = nextFamily.parents.findIndex(sameAs(unit));\n  index === 0 && nextFamily.parents[index].pos === 0 ? nextFamily.X = getUnitX(family, unit) : nextFamily.parents[index].pos = getUnitX(family, unit) - nextFamily.X;\n  var nextIdx = nextIndex(index);\n\n  if (nextFamily.parents[nextIdx]) {\n    correctUnitsShift(nextFamily.parents.slice(nextIdx), rightOf(family) - getUnitX(nextFamily, nextFamily.parents[nextIdx]));\n  }\n};\n\nexport var arrangeFamiliesFunc = function arrangeFamiliesFunc(store) {\n  return function (family) {\n    while (family.cid) {\n      var nextFamily = store.getFamily(family.cid);\n      var unit = family.children[0];\n\n      if (!nextFamily.cid) {\n        unit.pos = (widthOf(family) - nodeCount(unit) * SIZE) / 2;\n      } else {\n        if (family.parents.length === 2 && unitNodesCount(family.parents) > 2) unit.pos = Math.floor(family.parents[1].pos / 2);\n        arrangeNextFamily(family, nextFamily);\n      }\n\n      family = nextFamily;\n    }\n  };\n};","map":{"version":3,"sources":["/var/projets/broglie-social-react/sociala-react/node_modules/relatives-tree/lib/parents/arrange.js"],"names":["SIZE","correctUnitsShift","getUnitX","nodeCount","sameAs","rightOf","unitNodesCount","widthOf","nextIndex","arrangeNextFamily","family","nextFamily","unit","children","index","parents","findIndex","pos","X","nextIdx","slice","arrangeFamiliesFunc","store","cid","getFamily","length","Math","floor"],"mappings":"AAAA,SAASA,IAAT,QAAqB,cAArB;AACA,SAASC,iBAAT,EAA4BC,QAA5B,EAAsCC,SAAtC,EAAiDC,MAAjD,QAA+D,gBAA/D;AACA,SAASC,OAAT,EAAkBC,cAAlB,EAAkCC,OAAlC,QAAiD,iBAAjD;AACA,SAASC,SAAT,QAA0B,UAA1B;;AACA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,MAAD,EAASC,UAAT,EAAwB;AAC9C,MAAMC,IAAI,GAAGF,MAAM,CAACG,QAAP,CAAgB,CAAhB,CAAb;AACA,MAAMC,KAAK,GAAGH,UAAU,CAACI,OAAX,CAAmBC,SAAnB,CAA6BZ,MAAM,CAACQ,IAAD,CAAnC,CAAd;AACAE,EAAAA,KAAK,KAAK,CAAV,IAAeH,UAAU,CAACI,OAAX,CAAmBD,KAAnB,EAA0BG,GAA1B,KAAkC,CAAjD,GACMN,UAAU,CAACO,CAAX,GAAehB,QAAQ,CAACQ,MAAD,EAASE,IAAT,CAD7B,GAEMD,UAAU,CAACI,OAAX,CAAmBD,KAAnB,EAA0BG,GAA1B,GAAgCf,QAAQ,CAACQ,MAAD,EAASE,IAAT,CAAR,GAAyBD,UAAU,CAACO,CAF1E;AAGA,MAAMC,OAAO,GAAGX,SAAS,CAACM,KAAD,CAAzB;;AACA,MAAIH,UAAU,CAACI,OAAX,CAAmBI,OAAnB,CAAJ,EAAiC;AAC7BlB,IAAAA,iBAAiB,CAACU,UAAU,CAACI,OAAX,CAAmBK,KAAnB,CAAyBD,OAAzB,CAAD,EAAoCd,OAAO,CAACK,MAAD,CAAP,GAAkBR,QAAQ,CAACS,UAAD,EAAaA,UAAU,CAACI,OAAX,CAAmBI,OAAnB,CAAb,CAA9D,CAAjB;AACH;AACJ,CAVD;;AAWA,OAAO,IAAME,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,KAAD;AAAA,SAAY,UAACZ,MAAD,EAAY;AACvD,WAAOA,MAAM,CAACa,GAAd,EAAmB;AACf,UAAMZ,UAAU,GAAGW,KAAK,CAACE,SAAN,CAAgBd,MAAM,CAACa,GAAvB,CAAnB;AACA,UAAMX,IAAI,GAAGF,MAAM,CAACG,QAAP,CAAgB,CAAhB,CAAb;;AACA,UAAI,CAACF,UAAU,CAACY,GAAhB,EAAqB;AACjBX,QAAAA,IAAI,CAACK,GAAL,GAAW,CAACV,OAAO,CAACG,MAAD,CAAP,GAAkBP,SAAS,CAACS,IAAD,CAAT,GAAkBZ,IAArC,IAA6C,CAAxD;AACH,OAFD,MAGK;AACD,YAAIU,MAAM,CAACK,OAAP,CAAeU,MAAf,KAA0B,CAA1B,IAA+BnB,cAAc,CAACI,MAAM,CAACK,OAAR,CAAd,GAAiC,CAApE,EACIH,IAAI,CAACK,GAAL,GAAWS,IAAI,CAACC,KAAL,CAAWjB,MAAM,CAACK,OAAP,CAAe,CAAf,EAAkBE,GAAlB,GAAwB,CAAnC,CAAX;AACJR,QAAAA,iBAAiB,CAACC,MAAD,EAASC,UAAT,CAAjB;AACH;;AACDD,MAAAA,MAAM,GAAGC,UAAT;AACH;AACJ,GAdkC;AAAA,CAA5B","sourcesContent":["import { SIZE } from '../constants';\nimport { correctUnitsShift, getUnitX, nodeCount, sameAs } from '../utils/units';\nimport { rightOf, unitNodesCount, widthOf } from '../utils/family';\nimport { nextIndex } from '../utils';\nconst arrangeNextFamily = (family, nextFamily) => {\n    const unit = family.children[0];\n    const index = nextFamily.parents.findIndex(sameAs(unit));\n    index === 0 && nextFamily.parents[index].pos === 0\n        ? nextFamily.X = getUnitX(family, unit)\n        : nextFamily.parents[index].pos = getUnitX(family, unit) - nextFamily.X;\n    const nextIdx = nextIndex(index);\n    if (nextFamily.parents[nextIdx]) {\n        correctUnitsShift(nextFamily.parents.slice(nextIdx), rightOf(family) - getUnitX(nextFamily, nextFamily.parents[nextIdx]));\n    }\n};\nexport const arrangeFamiliesFunc = (store) => ((family) => {\n    while (family.cid) {\n        const nextFamily = store.getFamily(family.cid);\n        const unit = family.children[0];\n        if (!nextFamily.cid) {\n            unit.pos = (widthOf(family) - nodeCount(unit) * SIZE) / 2;\n        }\n        else {\n            if (family.parents.length === 2 && unitNodesCount(family.parents) > 2)\n                unit.pos = Math.floor(family.parents[1].pos / 2);\n            arrangeNextFamily(family, nextFamily);\n        }\n        family = nextFamily;\n    }\n});\n"]},"metadata":{},"sourceType":"module"}