{"ast":null,"code":"import { inAscOrder, withId } from '../utils';\nimport { getUnitX, nodeCount } from '../utils/units';\nimport { withType } from '../utils/family';\nimport { HALF_SIZE, NODES_IN_COUPLE, SIZE } from '../constants';\nimport { FamilyType } from '../types';\n\nconst calcConnectors = (family, families) => (connectors, unit) => {\n  const pX = getUnitX(family, unit) + HALF_SIZE;\n  const pY = family.Y + HALF_SIZE;\n\n  if (nodeCount(unit) === NODES_IN_COUPLE) {\n    connectors.push([pX, pY, pX + SIZE, pY]);\n  } else if (nodeCount(unit) === 1 && unit.nodes[0].spouses.length) {\n    families.filter(item => item.id !== family.id).forEach(other => {\n      other.parents.forEach(parent => {\n        if (parent.nodes.some(withId(unit.nodes[0].spouses[0].id))) {\n          const xX = [pX, getUnitX(other, parent) + HALF_SIZE].sort(inAscOrder);\n          connectors.push([xX[0], pY, xX[1], pY]);\n        }\n      });\n    });\n  }\n\n  return connectors;\n};\n\nexport const middle = families => {\n  const rootFamilies = families.filter(withType(FamilyType.root));\n  return rootFamilies.reduce((connectors, family) => connectors.concat(family.parents.reduce(calcConnectors(family, rootFamilies), [])), []);\n};","map":{"version":3,"sources":["/var/projets/broglie-social-react/sociala-react/node_modules/relatives-tree/lib/connectors/middle.js"],"names":["inAscOrder","withId","getUnitX","nodeCount","withType","HALF_SIZE","NODES_IN_COUPLE","SIZE","FamilyType","calcConnectors","family","families","connectors","unit","pX","pY","Y","push","nodes","spouses","length","filter","item","id","forEach","other","parents","parent","some","xX","sort","middle","rootFamilies","root","reduce","concat"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,MAArB,QAAmC,UAAnC;AACA,SAASC,QAAT,EAAmBC,SAAnB,QAAoC,gBAApC;AACA,SAASC,QAAT,QAAyB,iBAAzB;AACA,SAASC,SAAT,EAAoBC,eAApB,EAAqCC,IAArC,QAAiD,cAAjD;AACA,SAASC,UAAT,QAA2B,UAA3B;;AACA,MAAMC,cAAc,GAAG,CAACC,MAAD,EAASC,QAAT,KAAuB,CAACC,UAAD,EAAaC,IAAb,KAAsB;AAChE,QAAMC,EAAE,GAAGZ,QAAQ,CAACQ,MAAD,EAASG,IAAT,CAAR,GAAyBR,SAApC;AACA,QAAMU,EAAE,GAAGL,MAAM,CAACM,CAAP,GAAWX,SAAtB;;AACA,MAAIF,SAAS,CAACU,IAAD,CAAT,KAAoBP,eAAxB,EAAyC;AACrCM,IAAAA,UAAU,CAACK,IAAX,CAAgB,CAACH,EAAD,EAAKC,EAAL,EAASD,EAAE,GAAGP,IAAd,EAAoBQ,EAApB,CAAhB;AACH,GAFD,MAGK,IAAIZ,SAAS,CAACU,IAAD,CAAT,KAAoB,CAApB,IAAyBA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcC,OAAd,CAAsBC,MAAnD,EAA2D;AAC5DT,IAAAA,QAAQ,CACHU,MADL,CACYC,IAAI,IAAIA,IAAI,CAACC,EAAL,KAAYb,MAAM,CAACa,EADvC,EAEKC,OAFL,CAEaC,KAAK,IAAI;AAClBA,MAAAA,KAAK,CAACC,OAAN,CAAcF,OAAd,CAAsBG,MAAM,IAAI;AAC5B,YAAIA,MAAM,CAACT,KAAP,CAAaU,IAAb,CAAkB3B,MAAM,CAACY,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcC,OAAd,CAAsB,CAAtB,EAAyBI,EAA1B,CAAxB,CAAJ,EAA4D;AACxD,gBAAMM,EAAE,GAAG,CAACf,EAAD,EAAKZ,QAAQ,CAACuB,KAAD,EAAQE,MAAR,CAAR,GAA0BtB,SAA/B,EAA0CyB,IAA1C,CAA+C9B,UAA/C,CAAX;AACAY,UAAAA,UAAU,CAACK,IAAX,CAAgB,CAACY,EAAE,CAAC,CAAD,CAAH,EAAQd,EAAR,EAAYc,EAAE,CAAC,CAAD,CAAd,EAAmBd,EAAnB,CAAhB;AACH;AACJ,OALD;AAMH,KATD;AAUH;;AACD,SAAOH,UAAP;AACH,CAnBD;;AAoBA,OAAO,MAAMmB,MAAM,GAAIpB,QAAD,IAAc;AAChC,QAAMqB,YAAY,GAAGrB,QAAQ,CAACU,MAAT,CAAgBjB,QAAQ,CAACI,UAAU,CAACyB,IAAZ,CAAxB,CAArB;AACA,SAAOD,YAAY,CAACE,MAAb,CAAoB,CAACtB,UAAD,EAAaF,MAAb,KAAyBE,UAAU,CAACuB,MAAX,CAAkBzB,MAAM,CAACgB,OAAP,CAAeQ,MAAf,CAAsBzB,cAAc,CAACC,MAAD,EAASsB,YAAT,CAApC,EAA4D,EAA5D,CAAlB,CAA7C,EAAkI,EAAlI,CAAP;AACH,CAHM","sourcesContent":["import { inAscOrder, withId } from '../utils';\nimport { getUnitX, nodeCount } from '../utils/units';\nimport { withType } from '../utils/family';\nimport { HALF_SIZE, NODES_IN_COUPLE, SIZE } from '../constants';\nimport { FamilyType } from '../types';\nconst calcConnectors = (family, families) => ((connectors, unit) => {\n    const pX = getUnitX(family, unit) + HALF_SIZE;\n    const pY = family.Y + HALF_SIZE;\n    if (nodeCount(unit) === NODES_IN_COUPLE) {\n        connectors.push([pX, pY, pX + SIZE, pY]);\n    }\n    else if (nodeCount(unit) === 1 && unit.nodes[0].spouses.length) {\n        families\n            .filter(item => item.id !== family.id)\n            .forEach(other => {\n            other.parents.forEach(parent => {\n                if (parent.nodes.some(withId(unit.nodes[0].spouses[0].id))) {\n                    const xX = [pX, getUnitX(other, parent) + HALF_SIZE].sort(inAscOrder);\n                    connectors.push([xX[0], pY, xX[1], pY]);\n                }\n            });\n        });\n    }\n    return connectors;\n});\nexport const middle = (families) => {\n    const rootFamilies = families.filter(withType(FamilyType.root));\n    return rootFamilies.reduce((connectors, family) => (connectors.concat(family.parents.reduce(calcConnectors(family, rootFamilies), []))), []);\n};\n"]},"metadata":{},"sourceType":"module"}