{"ast":null,"code":"import { prop, withIds } from '../utils';\nimport { getUnitX, nodeCount } from '../utils/units';\nimport { getParentsX, withType } from '../utils/family';\nimport { HALF_SIZE, NODES_IN_COUPLE, SIZE } from '../constants';\nimport { FamilyType } from '../types';\n\nconst getChildIDs = unit => unit.nodes.map(prop('children')).flat().map(prop('id'));\n\nconst calcConnectors = family => (connectors, unit) => {\n  const pX = getParentsX(family, unit);\n  const pY = family.Y + HALF_SIZE;\n  const mY = family.Y + SIZE;\n  if (nodeCount(unit) === NODES_IN_COUPLE) connectors.push([pX - HALF_SIZE, pY, pX + HALF_SIZE, pY]);\n  connectors.push([pX, pY, pX, mY]);\n  const child = family.children[0];\n  const cX = getUnitX(family, child) + child.nodes.findIndex(withIds(getChildIDs(unit))) * SIZE + HALF_SIZE;\n  connectors.push([cX, mY, cX, mY + HALF_SIZE]);\n  if (pX !== cX) connectors.push([Math.min(pX, cX), mY, Math.max(pX, cX), mY]);\n  return connectors;\n};\n\nexport const parents = families => families.filter(withType(FamilyType.parent)).reduce((connectors, family) => connectors.concat(family.parents.reduce(calcConnectors(family), [])), []);","map":{"version":3,"sources":["/var/projets/broglie-social-react/sociala-react/node_modules/relatives-tree/lib/connectors/parents.js"],"names":["prop","withIds","getUnitX","nodeCount","getParentsX","withType","HALF_SIZE","NODES_IN_COUPLE","SIZE","FamilyType","getChildIDs","unit","nodes","map","flat","calcConnectors","family","connectors","pX","pY","Y","mY","push","child","children","cX","findIndex","Math","min","max","parents","families","filter","parent","reduce","concat"],"mappings":"AAAA,SAASA,IAAT,EAAeC,OAAf,QAA8B,UAA9B;AACA,SAASC,QAAT,EAAmBC,SAAnB,QAAoC,gBAApC;AACA,SAASC,WAAT,EAAsBC,QAAtB,QAAsC,iBAAtC;AACA,SAASC,SAAT,EAAoBC,eAApB,EAAqCC,IAArC,QAAiD,cAAjD;AACA,SAASC,UAAT,QAA2B,UAA3B;;AACA,MAAMC,WAAW,GAAIC,IAAD,IAAWA,IAAI,CAACC,KAAL,CAAWC,GAAX,CAAeb,IAAI,CAAC,UAAD,CAAnB,EAAiCc,IAAjC,GAAwCD,GAAxC,CAA4Cb,IAAI,CAAC,IAAD,CAAhD,CAA/B;;AACA,MAAMe,cAAc,GAAIC,MAAD,IAAa,CAACC,UAAD,EAAaN,IAAb,KAAsB;AACtD,QAAMO,EAAE,GAAGd,WAAW,CAACY,MAAD,EAASL,IAAT,CAAtB;AACA,QAAMQ,EAAE,GAAGH,MAAM,CAACI,CAAP,GAAWd,SAAtB;AACA,QAAMe,EAAE,GAAGL,MAAM,CAACI,CAAP,GAAWZ,IAAtB;AACA,MAAIL,SAAS,CAACQ,IAAD,CAAT,KAAoBJ,eAAxB,EACIU,UAAU,CAACK,IAAX,CAAgB,CAACJ,EAAE,GAAGZ,SAAN,EAAiBa,EAAjB,EAAqBD,EAAE,GAAGZ,SAA1B,EAAqCa,EAArC,CAAhB;AACJF,EAAAA,UAAU,CAACK,IAAX,CAAgB,CAACJ,EAAD,EAAKC,EAAL,EAASD,EAAT,EAAaG,EAAb,CAAhB;AACA,QAAME,KAAK,GAAGP,MAAM,CAACQ,QAAP,CAAgB,CAAhB,CAAd;AACA,QAAMC,EAAE,GAAIvB,QAAQ,CAACc,MAAD,EAASO,KAAT,CAAR,GACPA,KAAK,CAACX,KAAN,CAAYc,SAAZ,CAAsBzB,OAAO,CAACS,WAAW,CAACC,IAAD,CAAZ,CAA7B,IAAoDH,IAD7C,GACqDF,SADjE;AAEAW,EAAAA,UAAU,CAACK,IAAX,CAAgB,CAACG,EAAD,EAAKJ,EAAL,EAASI,EAAT,EAAaJ,EAAE,GAAGf,SAAlB,CAAhB;AACA,MAAIY,EAAE,KAAKO,EAAX,EACIR,UAAU,CAACK,IAAX,CAAgB,CAACK,IAAI,CAACC,GAAL,CAASV,EAAT,EAAaO,EAAb,CAAD,EAAmBJ,EAAnB,EAAuBM,IAAI,CAACE,GAAL,CAASX,EAAT,EAAaO,EAAb,CAAvB,EAAyCJ,EAAzC,CAAhB;AACJ,SAAOJ,UAAP;AACH,CAdD;;AAeA,OAAO,MAAMa,OAAO,GAAIC,QAAD,IAAeA,QAAQ,CACzCC,MADiC,CAC1B3B,QAAQ,CAACI,UAAU,CAACwB,MAAZ,CADkB,EAEjCC,MAFiC,CAE1B,CAACjB,UAAD,EAAaD,MAAb,KAAyBC,UAAU,CAACkB,MAAX,CAAkBnB,MAAM,CAACc,OAAP,CAAeI,MAAf,CAAsBnB,cAAc,CAACC,MAAD,CAApC,EAA8C,EAA9C,CAAlB,CAFC,EAEsE,EAFtE,CAA/B","sourcesContent":["import { prop, withIds } from '../utils';\nimport { getUnitX, nodeCount } from '../utils/units';\nimport { getParentsX, withType } from '../utils/family';\nimport { HALF_SIZE, NODES_IN_COUPLE, SIZE } from '../constants';\nimport { FamilyType } from '../types';\nconst getChildIDs = (unit) => (unit.nodes.map(prop('children')).flat().map(prop('id')));\nconst calcConnectors = (family) => ((connectors, unit) => {\n    const pX = getParentsX(family, unit);\n    const pY = family.Y + HALF_SIZE;\n    const mY = family.Y + SIZE;\n    if (nodeCount(unit) === NODES_IN_COUPLE)\n        connectors.push([pX - HALF_SIZE, pY, pX + HALF_SIZE, pY]);\n    connectors.push([pX, pY, pX, mY]);\n    const child = family.children[0];\n    const cX = (getUnitX(family, child) +\n        (child.nodes.findIndex(withIds(getChildIDs(unit))) * SIZE) + HALF_SIZE);\n    connectors.push([cX, mY, cX, mY + HALF_SIZE]);\n    if (pX !== cX)\n        connectors.push([Math.min(pX, cX), mY, Math.max(pX, cX), mY]);\n    return connectors;\n});\nexport const parents = (families) => (families\n    .filter(withType(FamilyType.parent))\n    .reduce((connectors, family) => (connectors.concat(family.parents.reduce(calcConnectors(family), []))), []));\n"]},"metadata":{},"sourceType":"module"}