{"ast":null,"code":"import _slicedToArray from \"/var/projets/broglie-social-react/sociala-react/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { NODES_IN_COUPLE } from '../constants';\nimport { RelType } from '../types';\nimport { byGender, relToNode, withRelType } from './index';\n\nvar inDescOrderOfChildCount = function inDescOrderOfChildCount(a, b) {\n  return b.children.length - a.children.length;\n};\n\nvar getSpouse = function getSpouse(store, spouses) {\n  var toNode = relToNode(store);\n  var married = spouses.find(withRelType(RelType.married));\n  if (married) return toNode(married);\n  if (spouses.length >= 1) return spouses.map(toNode).sort(inDescOrderOfChildCount)[0];\n  return;\n};\n\nvar getCoupleNodes = function getCoupleNodes(store, target) {\n  return [target, getSpouse(store, target.spouses)].filter(function (node) {\n    return Boolean(node);\n  }).sort(byGender(store.root.gender));\n};\n\nvar excludeRel = function excludeRel(target) {\n  return function (rel) {\n    return rel.id !== target.id;\n  };\n};\n\nexport var getSpouseNodesFunc = function getSpouseNodesFunc(store) {\n  var toNode = relToNode(store);\n  return function (parents) {\n    var middle = parents;\n    if (middle.length !== NODES_IN_COUPLE) middle = getCoupleNodes(store, middle[0]);\n    var result = {\n      left: [],\n      middle: middle,\n      right: []\n    };\n\n    if (middle.length === NODES_IN_COUPLE) {\n      var _middle = middle,\n          _middle2 = _slicedToArray(_middle, 2),\n          first = _middle2[0],\n          second = _middle2[1];\n\n      result.left = first.spouses.filter(excludeRel(second)).map(toNode);\n      result.right = second.spouses.filter(excludeRel(first)).map(toNode);\n    }\n\n    return result;\n  };\n};","map":{"version":3,"sources":["/var/projets/broglie-social-react/sociala-react/node_modules/relatives-tree/lib/utils/getSpouseNodesFunc.js"],"names":["NODES_IN_COUPLE","RelType","byGender","relToNode","withRelType","inDescOrderOfChildCount","a","b","children","length","getSpouse","store","spouses","toNode","married","find","map","sort","getCoupleNodes","target","filter","node","Boolean","root","gender","excludeRel","rel","id","getSpouseNodesFunc","parents","middle","result","left","right","first","second"],"mappings":";AAAA,SAASA,eAAT,QAAgC,cAAhC;AACA,SAASC,OAAT,QAAwB,UAAxB;AACA,SAASC,QAAT,EAAmBC,SAAnB,EAA8BC,WAA9B,QAAiD,SAAjD;;AACA,IAAMC,uBAAuB,GAAG,SAA1BA,uBAA0B,CAACC,CAAD,EAAIC,CAAJ;AAAA,SAAWA,CAAC,CAACC,QAAF,CAAWC,MAAX,GAAoBH,CAAC,CAACE,QAAF,CAAWC,MAA1C;AAAA,CAAhC;;AACA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,KAAD,EAAQC,OAAR,EAAoB;AAClC,MAAMC,MAAM,GAAGV,SAAS,CAACQ,KAAD,CAAxB;AACA,MAAMG,OAAO,GAAGF,OAAO,CAACG,IAAR,CAAaX,WAAW,CAACH,OAAO,CAACa,OAAT,CAAxB,CAAhB;AACA,MAAIA,OAAJ,EACI,OAAOD,MAAM,CAACC,OAAD,CAAb;AACJ,MAAIF,OAAO,CAACH,MAAR,IAAkB,CAAtB,EACI,OAAOG,OAAO,CAACI,GAAR,CAAYH,MAAZ,EAAoBI,IAApB,CAAyBZ,uBAAzB,EAAkD,CAAlD,CAAP;AACJ;AACH,CARD;;AASA,IAAMa,cAAc,GAAG,SAAjBA,cAAiB,CAACP,KAAD,EAAQQ,MAAR,EAAmB;AACtC,SAAO,CAACA,MAAD,EAAST,SAAS,CAACC,KAAD,EAAQQ,MAAM,CAACP,OAAf,CAAlB,EACFQ,MADE,CACK,UAACC,IAAD;AAAA,WAAUC,OAAO,CAACD,IAAD,CAAjB;AAAA,GADL,EAEFJ,IAFE,CAEGf,QAAQ,CAACS,KAAK,CAACY,IAAN,CAAWC,MAAZ,CAFX,CAAP;AAGH,CAJD;;AAKA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACN,MAAD;AAAA,SAAY,UAACO,GAAD;AAAA,WAASA,GAAG,CAACC,EAAJ,KAAWR,MAAM,CAACQ,EAA3B;AAAA,GAAZ;AAAA,CAAnB;;AACA,OAAO,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAACjB,KAAD,EAAW;AACzC,MAAME,MAAM,GAAGV,SAAS,CAACQ,KAAD,CAAxB;AACA,SAAO,UAACkB,OAAD,EAAa;AAChB,QAAIC,MAAM,GAAGD,OAAb;AACA,QAAIC,MAAM,CAACrB,MAAP,KAAkBT,eAAtB,EACI8B,MAAM,GAAGZ,cAAc,CAACP,KAAD,EAAQmB,MAAM,CAAC,CAAD,CAAd,CAAvB;AACJ,QAAMC,MAAM,GAAG;AAAEC,MAAAA,IAAI,EAAE,EAAR;AAAYF,MAAAA,MAAM,EAANA,MAAZ;AAAoBG,MAAAA,KAAK,EAAE;AAA3B,KAAf;;AACA,QAAIH,MAAM,CAACrB,MAAP,KAAkBT,eAAtB,EAAuC;AACnC,oBAAwB8B,MAAxB;AAAA;AAAA,UAAOI,KAAP;AAAA,UAAcC,MAAd;;AACAJ,MAAAA,MAAM,CAACC,IAAP,GAAcE,KAAK,CAACtB,OAAN,CAAcQ,MAAd,CAAqBK,UAAU,CAACU,MAAD,CAA/B,EAAyCnB,GAAzC,CAA6CH,MAA7C,CAAd;AACAkB,MAAAA,MAAM,CAACE,KAAP,GAAeE,MAAM,CAACvB,OAAP,CAAeQ,MAAf,CAAsBK,UAAU,CAACS,KAAD,CAAhC,EAAyClB,GAAzC,CAA6CH,MAA7C,CAAf;AACH;;AACD,WAAOkB,MAAP;AACH,GAXD;AAYH,CAdM","sourcesContent":["import { NODES_IN_COUPLE } from '../constants';\nimport { RelType } from '../types';\nimport { byGender, relToNode, withRelType } from './index';\nconst inDescOrderOfChildCount = (a, b) => (b.children.length - a.children.length);\nconst getSpouse = (store, spouses) => {\n    const toNode = relToNode(store);\n    const married = spouses.find(withRelType(RelType.married));\n    if (married)\n        return toNode(married);\n    if (spouses.length >= 1)\n        return spouses.map(toNode).sort(inDescOrderOfChildCount)[0];\n    return;\n};\nconst getCoupleNodes = (store, target) => {\n    return [target, getSpouse(store, target.spouses)]\n        .filter((node) => Boolean(node))\n        .sort(byGender(store.root.gender));\n};\nconst excludeRel = (target) => (rel) => rel.id !== target.id;\nexport const getSpouseNodesFunc = (store) => {\n    const toNode = relToNode(store);\n    return (parents) => {\n        let middle = parents;\n        if (middle.length !== NODES_IN_COUPLE)\n            middle = getCoupleNodes(store, middle[0]);\n        const result = { left: [], middle, right: [] };\n        if (middle.length === NODES_IN_COUPLE) {\n            const [first, second] = middle;\n            result.left = first.spouses.filter(excludeRel(second)).map(toNode);\n            result.right = second.spouses.filter(excludeRel(first)).map(toNode);\n        }\n        return result;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}