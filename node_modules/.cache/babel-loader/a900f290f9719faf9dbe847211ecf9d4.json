{"ast":null,"code":"import { getParentsX, withType } from '../utils/family';\nimport { getUnitX, nodeCount, nodeIds } from '../utils/units';\nimport { inAscOrder, max, min, withId, withIds } from '../utils';\nimport { HALF_SIZE, NODES_IN_COUPLE, SIZE } from '../constants';\nimport { FamilyType } from '../types';\nexport const children = families => families.filter(withType(FamilyType.root, FamilyType.child)).reduce((connectors, family) => {\n  const parent = family.parents[0];\n  const pX = getParentsX(family, parent);\n  const mY = family.Y + (parent ? SIZE : 0);\n\n  if (parent && parent.nodes.every(node => !!node.children.length)) {\n    const pY = family.Y + HALF_SIZE;\n    connectors.push([pX, pY, pX, mY]);\n  }\n\n  const parentIds = family.parents.map(nodeIds).flat();\n  const positions = [];\n  family.children.forEach(unit => {\n    const left = getUnitX(family, unit) + HALF_SIZE;\n    unit.nodes.forEach((node, index) => {\n      if (node.parents.some(withIds(parentIds))) {\n        const nX = left + index * SIZE;\n        positions.push(nX);\n        connectors.push([nX, mY, nX, mY + HALF_SIZE]);\n      }\n    });\n\n    if (nodeCount(unit) === NODES_IN_COUPLE) {\n      connectors.push([left, mY + HALF_SIZE, left + SIZE, mY + HALF_SIZE]);\n    } else if (nodeCount(unit) === 1 && unit.nodes[0].spouses.length) {\n      family.children.forEach(nUnit => {\n        if (nUnit.nodes.some(withId(unit.nodes[0].spouses[0].id))) {\n          const xX = [left, getUnitX(family, nUnit) + HALF_SIZE].sort(inAscOrder);\n          connectors.push([xX[0], mY + HALF_SIZE, xX[1], mY + HALF_SIZE]);\n        }\n      });\n    }\n  });\n  if (positions.length > 1) connectors.push([min(positions), mY, max(positions), mY]);else if (positions.length === 1 && pX !== positions[0]) connectors.push([Math.min(pX, positions[0]), mY, Math.max(pX, positions[0]), mY]);\n  return connectors;\n}, []);","map":{"version":3,"sources":["/var/projets/broglie-social-react/sociala-react/node_modules/relatives-tree/lib/connectors/children.js"],"names":["getParentsX","withType","getUnitX","nodeCount","nodeIds","inAscOrder","max","min","withId","withIds","HALF_SIZE","NODES_IN_COUPLE","SIZE","FamilyType","children","families","filter","root","child","reduce","connectors","family","parent","parents","pX","mY","Y","nodes","every","node","length","pY","push","parentIds","map","flat","positions","forEach","unit","left","index","some","nX","spouses","nUnit","id","xX","sort","Math"],"mappings":"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","sourcesContent":["import { getParentsX, withType } from '../utils/family';\nimport { getUnitX, nodeCount, nodeIds } from '../utils/units';\nimport { inAscOrder, max, min, withId, withIds } from '../utils';\nimport { HALF_SIZE, NODES_IN_COUPLE, SIZE } from '../constants';\nimport { FamilyType } from '../types';\nexport const children = (families) => (families\n    .filter(withType(FamilyType.root, FamilyType.child))\n    .reduce((connectors, family) => {\n    const parent = family.parents[0];\n    const pX = getParentsX(family, parent);\n    const mY = family.Y + (parent ? SIZE : 0);\n    if (parent && parent.nodes.every(node => !!node.children.length)) {\n        const pY = family.Y + HALF_SIZE;\n        connectors.push([pX, pY, pX, mY]);\n    }\n    const parentIds = family.parents.map(nodeIds).flat();\n    const positions = [];\n    family.children.forEach(unit => {\n        const left = getUnitX(family, unit) + HALF_SIZE;\n        unit.nodes.forEach((node, index) => {\n            if (node.parents.some(withIds(parentIds))) {\n                const nX = left + (index * SIZE);\n                positions.push(nX);\n                connectors.push([nX, mY, nX, mY + HALF_SIZE]);\n            }\n        });\n        if (nodeCount(unit) === NODES_IN_COUPLE) {\n            connectors.push([left, mY + HALF_SIZE, left + SIZE, mY + HALF_SIZE]);\n        }\n        else if (nodeCount(unit) === 1 && unit.nodes[0].spouses.length) {\n            family.children.forEach(nUnit => {\n                if (nUnit.nodes.some(withId(unit.nodes[0].spouses[0].id))) {\n                    const xX = [left, getUnitX(family, nUnit) + HALF_SIZE].sort(inAscOrder);\n                    connectors.push([xX[0], mY + HALF_SIZE, xX[1], mY + HALF_SIZE]);\n                }\n            });\n        }\n    });\n    if (positions.length > 1)\n        connectors.push([min(positions), mY, max(positions), mY]);\n    else if (positions.length === 1 && pX !== positions[0])\n        connectors.push([Math.min(pX, positions[0]), mY, Math.max(pX, positions[0]), mY]);\n    return connectors;\n}, []));\n"]},"metadata":{},"sourceType":"module"}