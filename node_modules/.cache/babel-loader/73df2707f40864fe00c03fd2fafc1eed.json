{"ast":null,"code":"import { NODES_IN_COUPLE } from '../constants';\nimport { RelType } from '../types';\nimport { byGender, relToNode, withRelType } from './index';\n\nconst inDescOrderOfChildCount = (a, b) => b.children.length - a.children.length;\n\nconst getSpouse = (store, spouses) => {\n  const toNode = relToNode(store);\n  const married = spouses.find(withRelType(RelType.married));\n  if (married) return toNode(married);\n  if (spouses.length >= 1) return spouses.map(toNode).sort(inDescOrderOfChildCount)[0];\n  return;\n};\n\nconst getCoupleNodes = (store, target) => {\n  return [target, getSpouse(store, target.spouses)].filter(node => Boolean(node)).sort(byGender(store.root.gender));\n};\n\nconst excludeRel = target => rel => rel.id !== target.id;\n\nexport const getSpouseNodesFunc = store => {\n  const toNode = relToNode(store);\n  return parents => {\n    let middle = parents;\n    if (middle.length !== NODES_IN_COUPLE) middle = getCoupleNodes(store, middle[0]);\n    const result = {\n      left: [],\n      middle,\n      right: []\n    };\n\n    if (middle.length === NODES_IN_COUPLE) {\n      const [first, second] = middle;\n      result.left = first.spouses.filter(excludeRel(second)).map(toNode);\n      result.right = second.spouses.filter(excludeRel(first)).map(toNode);\n    }\n\n    return result;\n  };\n};","map":{"version":3,"sources":["/var/projets/broglie-social-react/sociala-react/node_modules/relatives-tree/lib/utils/getSpouseNodesFunc.js"],"names":["NODES_IN_COUPLE","RelType","byGender","relToNode","withRelType","inDescOrderOfChildCount","a","b","children","length","getSpouse","store","spouses","toNode","married","find","map","sort","getCoupleNodes","target","filter","node","Boolean","root","gender","excludeRel","rel","id","getSpouseNodesFunc","parents","middle","result","left","right","first","second"],"mappings":"AAAA,SAASA,eAAT,QAAgC,cAAhC;AACA,SAASC,OAAT,QAAwB,UAAxB;AACA,SAASC,QAAT,EAAmBC,SAAnB,EAA8BC,WAA9B,QAAiD,SAAjD;;AACA,MAAMC,uBAAuB,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAWA,CAAC,CAACC,QAAF,CAAWC,MAAX,GAAoBH,CAAC,CAACE,QAAF,CAAWC,MAA1E;;AACA,MAAMC,SAAS,GAAG,CAACC,KAAD,EAAQC,OAAR,KAAoB;AAClC,QAAMC,MAAM,GAAGV,SAAS,CAACQ,KAAD,CAAxB;AACA,QAAMG,OAAO,GAAGF,OAAO,CAACG,IAAR,CAAaX,WAAW,CAACH,OAAO,CAACa,OAAT,CAAxB,CAAhB;AACA,MAAIA,OAAJ,EACI,OAAOD,MAAM,CAACC,OAAD,CAAb;AACJ,MAAIF,OAAO,CAACH,MAAR,IAAkB,CAAtB,EACI,OAAOG,OAAO,CAACI,GAAR,CAAYH,MAAZ,EAAoBI,IAApB,CAAyBZ,uBAAzB,EAAkD,CAAlD,CAAP;AACJ;AACH,CARD;;AASA,MAAMa,cAAc,GAAG,CAACP,KAAD,EAAQQ,MAAR,KAAmB;AACtC,SAAO,CAACA,MAAD,EAAST,SAAS,CAACC,KAAD,EAAQQ,MAAM,CAACP,OAAf,CAAlB,EACFQ,MADE,CACMC,IAAD,IAAUC,OAAO,CAACD,IAAD,CADtB,EAEFJ,IAFE,CAEGf,QAAQ,CAACS,KAAK,CAACY,IAAN,CAAWC,MAAZ,CAFX,CAAP;AAGH,CAJD;;AAKA,MAAMC,UAAU,GAAIN,MAAD,IAAaO,GAAD,IAASA,GAAG,CAACC,EAAJ,KAAWR,MAAM,CAACQ,EAA1D;;AACA,OAAO,MAAMC,kBAAkB,GAAIjB,KAAD,IAAW;AACzC,QAAME,MAAM,GAAGV,SAAS,CAACQ,KAAD,CAAxB;AACA,SAAQkB,OAAD,IAAa;AAChB,QAAIC,MAAM,GAAGD,OAAb;AACA,QAAIC,MAAM,CAACrB,MAAP,KAAkBT,eAAtB,EACI8B,MAAM,GAAGZ,cAAc,CAACP,KAAD,EAAQmB,MAAM,CAAC,CAAD,CAAd,CAAvB;AACJ,UAAMC,MAAM,GAAG;AAAEC,MAAAA,IAAI,EAAE,EAAR;AAAYF,MAAAA,MAAZ;AAAoBG,MAAAA,KAAK,EAAE;AAA3B,KAAf;;AACA,QAAIH,MAAM,CAACrB,MAAP,KAAkBT,eAAtB,EAAuC;AACnC,YAAM,CAACkC,KAAD,EAAQC,MAAR,IAAkBL,MAAxB;AACAC,MAAAA,MAAM,CAACC,IAAP,GAAcE,KAAK,CAACtB,OAAN,CAAcQ,MAAd,CAAqBK,UAAU,CAACU,MAAD,CAA/B,EAAyCnB,GAAzC,CAA6CH,MAA7C,CAAd;AACAkB,MAAAA,MAAM,CAACE,KAAP,GAAeE,MAAM,CAACvB,OAAP,CAAeQ,MAAf,CAAsBK,UAAU,CAACS,KAAD,CAAhC,EAAyClB,GAAzC,CAA6CH,MAA7C,CAAf;AACH;;AACD,WAAOkB,MAAP;AACH,GAXD;AAYH,CAdM","sourcesContent":["import { NODES_IN_COUPLE } from '../constants';\nimport { RelType } from '../types';\nimport { byGender, relToNode, withRelType } from './index';\nconst inDescOrderOfChildCount = (a, b) => (b.children.length - a.children.length);\nconst getSpouse = (store, spouses) => {\n    const toNode = relToNode(store);\n    const married = spouses.find(withRelType(RelType.married));\n    if (married)\n        return toNode(married);\n    if (spouses.length >= 1)\n        return spouses.map(toNode).sort(inDescOrderOfChildCount)[0];\n    return;\n};\nconst getCoupleNodes = (store, target) => {\n    return [target, getSpouse(store, target.spouses)]\n        .filter((node) => Boolean(node))\n        .sort(byGender(store.root.gender));\n};\nconst excludeRel = (target) => (rel) => rel.id !== target.id;\nexport const getSpouseNodesFunc = (store) => {\n    const toNode = relToNode(store);\n    return (parents) => {\n        let middle = parents;\n        if (middle.length !== NODES_IN_COUPLE)\n            middle = getCoupleNodes(store, middle[0]);\n        const result = { left: [], middle, right: [] };\n        if (middle.length === NODES_IN_COUPLE) {\n            const [first, second] = middle;\n            result.left = first.spouses.filter(excludeRel(second)).map(toNode);\n            result.right = second.spouses.filter(excludeRel(first)).map(toNode);\n        }\n        return result;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}