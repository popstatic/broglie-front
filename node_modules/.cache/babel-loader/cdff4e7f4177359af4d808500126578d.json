{"ast":null,"code":"import { inAscOrder, withId } from '../utils';\nimport { getUnitX, nodeCount } from '../utils/units';\nimport { withType } from '../utils/family';\nimport { HALF_SIZE, NODES_IN_COUPLE, SIZE } from '../constants';\nimport { FamilyType } from '../types';\n\nvar calcConnectors = function calcConnectors(family, families) {\n  return function (connectors, unit) {\n    var pX = getUnitX(family, unit) + HALF_SIZE;\n    var pY = family.Y + HALF_SIZE;\n\n    if (nodeCount(unit) === NODES_IN_COUPLE) {\n      connectors.push([pX, pY, pX + SIZE, pY]);\n    } else if (nodeCount(unit) === 1 && unit.nodes[0].spouses.length) {\n      families.filter(function (item) {\n        return item.id !== family.id;\n      }).forEach(function (other) {\n        other.parents.forEach(function (parent) {\n          if (parent.nodes.some(withId(unit.nodes[0].spouses[0].id))) {\n            var xX = [pX, getUnitX(other, parent) + HALF_SIZE].sort(inAscOrder);\n            connectors.push([xX[0], pY, xX[1], pY]);\n          }\n        });\n      });\n    }\n\n    return connectors;\n  };\n};\n\nexport var middle = function middle(families) {\n  var rootFamilies = families.filter(withType(FamilyType.root));\n  return rootFamilies.reduce(function (connectors, family) {\n    return connectors.concat(family.parents.reduce(calcConnectors(family, rootFamilies), []));\n  }, []);\n};","map":{"version":3,"sources":["/var/projets/broglie-social-react/sociala-react/node_modules/relatives-tree/lib/connectors/middle.js"],"names":["inAscOrder","withId","getUnitX","nodeCount","withType","HALF_SIZE","NODES_IN_COUPLE","SIZE","FamilyType","calcConnectors","family","families","connectors","unit","pX","pY","Y","push","nodes","spouses","length","filter","item","id","forEach","other","parents","parent","some","xX","sort","middle","rootFamilies","root","reduce","concat"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,MAArB,QAAmC,UAAnC;AACA,SAASC,QAAT,EAAmBC,SAAnB,QAAoC,gBAApC;AACA,SAASC,QAAT,QAAyB,iBAAzB;AACA,SAASC,SAAT,EAAoBC,eAApB,EAAqCC,IAArC,QAAiD,cAAjD;AACA,SAASC,UAAT,QAA2B,UAA3B;;AACA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,MAAD,EAASC,QAAT;AAAA,SAAuB,UAACC,UAAD,EAAaC,IAAb,EAAsB;AAChE,QAAMC,EAAE,GAAGZ,QAAQ,CAACQ,MAAD,EAASG,IAAT,CAAR,GAAyBR,SAApC;AACA,QAAMU,EAAE,GAAGL,MAAM,CAACM,CAAP,GAAWX,SAAtB;;AACA,QAAIF,SAAS,CAACU,IAAD,CAAT,KAAoBP,eAAxB,EAAyC;AACrCM,MAAAA,UAAU,CAACK,IAAX,CAAgB,CAACH,EAAD,EAAKC,EAAL,EAASD,EAAE,GAAGP,IAAd,EAAoBQ,EAApB,CAAhB;AACH,KAFD,MAGK,IAAIZ,SAAS,CAACU,IAAD,CAAT,KAAoB,CAApB,IAAyBA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcC,OAAd,CAAsBC,MAAnD,EAA2D;AAC5DT,MAAAA,QAAQ,CACHU,MADL,CACY,UAAAC,IAAI;AAAA,eAAIA,IAAI,CAACC,EAAL,KAAYb,MAAM,CAACa,EAAvB;AAAA,OADhB,EAEKC,OAFL,CAEa,UAAAC,KAAK,EAAI;AAClBA,QAAAA,KAAK,CAACC,OAAN,CAAcF,OAAd,CAAsB,UAAAG,MAAM,EAAI;AAC5B,cAAIA,MAAM,CAACT,KAAP,CAAaU,IAAb,CAAkB3B,MAAM,CAACY,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcC,OAAd,CAAsB,CAAtB,EAAyBI,EAA1B,CAAxB,CAAJ,EAA4D;AACxD,gBAAMM,EAAE,GAAG,CAACf,EAAD,EAAKZ,QAAQ,CAACuB,KAAD,EAAQE,MAAR,CAAR,GAA0BtB,SAA/B,EAA0CyB,IAA1C,CAA+C9B,UAA/C,CAAX;AACAY,YAAAA,UAAU,CAACK,IAAX,CAAgB,CAACY,EAAE,CAAC,CAAD,CAAH,EAAQd,EAAR,EAAYc,EAAE,CAAC,CAAD,CAAd,EAAmBd,EAAnB,CAAhB;AACH;AACJ,SALD;AAMH,OATD;AAUH;;AACD,WAAOH,UAAP;AACH,GAnBsB;AAAA,CAAvB;;AAoBA,OAAO,IAAMmB,MAAM,GAAG,SAATA,MAAS,CAACpB,QAAD,EAAc;AAChC,MAAMqB,YAAY,GAAGrB,QAAQ,CAACU,MAAT,CAAgBjB,QAAQ,CAACI,UAAU,CAACyB,IAAZ,CAAxB,CAArB;AACA,SAAOD,YAAY,CAACE,MAAb,CAAoB,UAACtB,UAAD,EAAaF,MAAb;AAAA,WAAyBE,UAAU,CAACuB,MAAX,CAAkBzB,MAAM,CAACgB,OAAP,CAAeQ,MAAf,CAAsBzB,cAAc,CAACC,MAAD,EAASsB,YAAT,CAApC,EAA4D,EAA5D,CAAlB,CAAzB;AAAA,GAApB,EAAkI,EAAlI,CAAP;AACH,CAHM","sourcesContent":["import { inAscOrder, withId } from '../utils';\nimport { getUnitX, nodeCount } from '../utils/units';\nimport { withType } from '../utils/family';\nimport { HALF_SIZE, NODES_IN_COUPLE, SIZE } from '../constants';\nimport { FamilyType } from '../types';\nconst calcConnectors = (family, families) => ((connectors, unit) => {\n    const pX = getUnitX(family, unit) + HALF_SIZE;\n    const pY = family.Y + HALF_SIZE;\n    if (nodeCount(unit) === NODES_IN_COUPLE) {\n        connectors.push([pX, pY, pX + SIZE, pY]);\n    }\n    else if (nodeCount(unit) === 1 && unit.nodes[0].spouses.length) {\n        families\n            .filter(item => item.id !== family.id)\n            .forEach(other => {\n            other.parents.forEach(parent => {\n                if (parent.nodes.some(withId(unit.nodes[0].spouses[0].id))) {\n                    const xX = [pX, getUnitX(other, parent) + HALF_SIZE].sort(inAscOrder);\n                    connectors.push([xX[0], pY, xX[1], pY]);\n                }\n            });\n        });\n    }\n    return connectors;\n});\nexport const middle = (families) => {\n    const rootFamilies = families.filter(withType(FamilyType.root));\n    return rootFamilies.reduce((connectors, family) => (connectors.concat(family.parents.reduce(calcConnectors(family, rootFamilies), []))), []);\n};\n"]},"metadata":{},"sourceType":"module"}